# Runtime

___Runtime Go___ - это среда выполнения, обеспечивающая работу Go программ. Во время линковки runtime обязательно добавляется в Go-программу. Runtime состоит из механизмов и компонентов, которые контроллируют выполнение кода.

Главные из них:

1) ___Планировщик горутин (scheduler)___ управляет конкурентным выполнением множества горутин.
2) ___Аллокатор памяти (allocator)___ выделяет память.
3) ___Сборщик мусора (garbage collector, GC)___ удаляет мусор из памяти.

Их устройство и предназначение будет раскрыто в отдельных статьях. Сейчас же рассмотрим flow runtime: от запуска программы до выполнения функции main.

### 1. RUN

___RUN___ — это точка входа в процесс запуска Go Runtime. 

Фактически, когда программу запускается, прежде всего вызывается `runtime.main`. `runtime.main` запускает инициализацию runtime. Именно внутри него происходит запуск всех остальных сущностей runtime и вызов функции `main.main`.

### 2. TLS

___TLS (Thread Local Storage)___ — это механизм локального хранилища для потоков.

В Go разработчики не используют системные потоки напрямую, runtime предоставляет абстракцию под названием ___горутины___. Горутины работают поверх системных потоков, которые в свою очередь исполняются на процессорах.

В реализации runtime используются следующие обозначения:

1) Структура G - горутина.
2) Структура M - потока.
3) Структура P - процессора.

На каждый используемый поток runtime создает TLS. Данные в TLS изолированы от других потоков и, что самое главное, быстро доступны. Этот механизм помогает runtime быстро и эффективно получать доступ к данным, связанным с конкретным потоком, без необходимости глобальных блокировок или поиска.

### 3. SYSARGS (System Arguments)

___SYSARGS (System Arguments)___ — обработка и сохранение аргументов командной строки и данных окружения.

Полученные аргументы будут использованы для настройки runtime, например, настройка Garbage Collector, и будут переданы в `main.main`.

### 4. OS

___Этап OS___ настраивает runtime на взаимодействие с ОС:

1) Определение характеристик ОС: в зависимости от ОС выбираются специфические системные вызовы (дальше просто syscall) и параметры окружения.
2) Инициализация системных примитивов: потоки, виртуальная память, сигналы и т.п.
3) Настройка виртуальный памяти и страниц. Например, размер страниц будет в дальнейшем использовать аллокатор.
4) Подготовка к работе с потоками.
5) Подготовка к работе с файлами: устанавливаются соответствующие syscall для работы с файлами.

Примечание: этап TLS не зависит от конкретной OS, он идет перед OS, потому что попросту необходим для полноценного запуска самого runtime.

### 5. SCHEDULER

Runtime вызывает метод `proc.schedinit`, который инициализирует основные структуры планировщика:

1) `sched` - глобальная очередь горутин.
2) `allm` - список всех потоков.
3) `allp` - список всех виртуальных процессоров.

Дальше создаются виртуальные процессоры (P), которые связывают горутины (G) с потоками ОС (M). Планировщик создат первый первый потом. В дальнейшем потоки будут добавляться / удаляться по мере необходимости.

### 6. STOP THE WORLD

Во время инициализации происходит ___Stop the World (STW)___ - остановка всех существующих потоков и горутин.

Он производится, потому что перед инициализацией планировщика, уже есть как минимум две горутины: `g0` - горутина runtime-а и `main goroutine` - для запуска main и хотя бы один поток.

Благодаря STW настройка планировщика происходит безопасно.

### 7. STACKS POOLS

___Этап Stacks pools___ — это инициализация пула переиспользуемых стеков для горутин, чтобы избежать затратного выделения памяти при каждом создании горутины. 

Рантайм заранее резервирует стеки разных размеров (начиная с 2 КБ) и быстро переиспользует их, ускоряя запуск горутин и снижая нагрузку на сборщик мусора. Без этого пула массовое создание горутин было бы значительно медленнее из-за постоянных запросов памяти к ОС.


### 8. MEMORY ALLOCATOR

На этом этапе инициализируется ___система управления памятью___:

1) инициализация куч: глобальной и локальных.
2) инициализация страниц памяти.
3) создается Go-аллокатор памяти.
4) память делится на размерные классы (8 Б, 16 Б, ..., 32 КБ) для быстрого поиска свободных блоков.

### 9-11. CPU Flags, AES и RANDOM

___Этап CPU FLAGS___ — это проверка возможностей процессора (например, AES-NI, SSE, RDRAND) для выбора оптимальных алгоритмов в рантайме. Если CPU поддерживает аппаратное ускорение операций, Go использует его для повышения производительности криптографии, работы с памятью и других задач

___AES___ — инициализация аппаратного ускорения шифрования (если CPU поддерживает AES-NI, Go переключается с медленного программного кода на инструкции aesenc/aesenclast для криптографических операций).

___RANDOM___ — настройка генератора случайных чисел: использует аппаратные источники при их наличии, либо системные вызовы.

Эти этапы очень тесно связаны и представляют собой ___аппаратно-зависимую оптимизацию___ Go.

### 12. MAIN THREAD

___Этап Main Thread___ — это подготовка главного потока программы, где создаётся горутина для main() и настраивается её связь с планировщиком через TLS и первый виртуальный процессор (P). Здесь рантайм переходит от низкоуровневой инициализации к запуску пользовательского кода. Без этого этапа программа не смогла бы начать выполнение.

### 13. MODULES

Runtime загружает информацию о всех импортированных пакетах (включая их init-функции) и настраивает внутренние структуры для работы с ними.  Благодаря этому перед запуском main все зависимости будут уже готовы.

### 14. GO ARGS

Этот этап тесно связан с этапом SYSARGS. Только в нем Runtime:

1) Анализирует специальные аргумента флаги Go (вроде `-gcflags`, `-memprofilerate`), которые влияют на работу сборщика мусора, профилировщика и других компонентов.
2) Сохраняет все остальные аргументы (не начинающиеся с -) для дальнейшей обработки через `os.Args`.

### 15. GO ENV

___Этап Go env___ — обработка переменных окружения, управляющих работой рантайма (GC, планировщик, отладка).

Основные переменные:

- `GODEBUG` — отладочные флаги
- `GOGC` — агрессивность сборки мусора
- `GOMAXPROCS` — ограничение CPU для горутин
- `GOTRACEBACK` — детализация паники

### 16. SECURE

Обеспечивает базовую безопасность программ от уязвимостей. Например, переполнения буфера.

### 17. DEBUG ENV

Активации систем мониторинга и профилирования в рантайме.

Основные функции:

- Включает трассировку сборщика мусора при `GODEBUG=gctrace=1`.
- Активирует логи планировщика через `schedtrace=XXX`.
- Настраивает детализацию вывода при панике `GOTRACEBACK=crash`.

Например, вызов исполняемого файла таким образом:

```bash
GODEBUG=gctrace=1,schedtrace=1000 ./myapp
```

Выведет подробную информацию о работе GC и планировщика каждую секунду.

### 18. INIT GC

___Init GC___ — это этап инициализации сборщика мусора в Go. На этом шаге рантайм подготавливает все необходимые структуры данных и механизмы для работы GC перед тем, как программа начнёт выполнять пользовательский код.


### 19-20. PS и START THE WORLD

___Этап PS___ — это создание и настройка логических процессоров (P), которые непосредственно управляют выполнением горутин.

Напомню, что на SCHED идет общая подготовка планировщика (без привязки к CPU). На PS - создание и настройка виртуальных CPU (P), которые будут выполнять горутины.

Этот этап последний запуском всех горутин.

___Этап Start the world___ — это момент, когда runtime Go возобновляет выполнение всех остановленных горутин после завершения критических подготовительных этапов. Этот этап противопоставляется Stop the World.

### 21. ENABLE GC

___Enable GC___ — это этап, на котором сборщик мусора официально начинает работать в фоновом режиме. До этого момента GC был инициализирован (INIT GC), но не активен.

### 22. INITIAL G

___Initial G___ — это этап инициализации первой горутины (G), которая выполняет функцию `main()`.


### 22. SYSMON

___SYSMON (system monitor)___ — это критически важный фоновый процесс в Go, который запускается рантаймом для наблюдения за состоянием программы и выполнения обслуживающих задач.

Sysmon - это специальная горутина, которая работает в фоне на протяжении всей жизни программы и выполняет:

- Мониторинг deadlock'ов (зависших горутин)
- Сетевой polling (проверка заблокированных сетевых вызовов)
- Наблюдение за планировщиком
- Принудительный запуск GC в случае нехватки памяти
- Освобождение незанятых стеков
- Мониторинг системных вызовов


### 23. RUN INITS

___Run inits___ — это этап, на котором выполняются все функции `init()`, определённые в пакетах программы.

### 24-25. RUN MAIN и YOUR CODE

На последних этапах происходит запуск `main.main()` и всего последующего клиентского кода. 

Однако runtime все равно будет работать. Параллельно `main.main()` будет работать планировщик, сборщик мусора и прочие процессы.

### Источники:

- [Understanding the Go Runtime (GoLab)](https://www.youtube.com/watch?v=YpRNFNFaLGY&ab_channel=GoLabconference)
