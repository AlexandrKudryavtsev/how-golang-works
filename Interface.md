# Интерфейсы и динамическая диспетчеризация:

***Интерфейс в Go*** — это контракт, который определяет набор методов. Если тип реализует все эти методы, он автоматически удовлетворяет интерфейсу.  Благодаря ним достигает полиморфизм, без использования наследования.Интерфейсы в Go — ***неявные***: тип не объявляет, что он реализует интерфейс, компилятор проверяет это автоматически. Под капотом интерфейсы работают через ***динамическую диспетчеризацию***: вызов метода определяется не на этапе компиляции, а в рантайме.

## Статические и динамические типы

У каждой переменной в Go есть:

- Статический тип (известен на этапе компиляции) — например, `*os.File` или `int`.
- Динамический тип (определяется в рантайме) — конкретный тип значения, лежащего за интерфейсом.

Например, здесь `w` имеет статический тип `io.Writer`, но в рантайме хранит конкретное значение типа `*os.File`:

```golang
var w io.Writer  // статический тип — io.Writer, динамический — nil
w = os.Stdout    // теперь динамический тип — *os.File
```

## Реализация интерфейса

Рассмотрим реализацию интерфейса на примере:

```golang
type Writer interface {
    Write([]byte) (int, error)
}
```

При объявлении интерфейса компилятор Go фиксирует сигнатуры его методов и создаёт внутреннее представление интерфейса, но не привязывает его к конкретным типам.

```golang
func (f *os.File) Write(p []byte) (n int, err error) {
    // ...
}
```

Тип реализует интерфейс неявно — достаточно, чтобы его набор методов включал все методы интерфейса. В примере, `*os.File` автоматически удовлетворяет `Writer`, поскольку содержит метод.

Неявная реализация достигается за счет того, что компилятор для каждого типа строит ***таблицу методов*** (порядок, сигнатуры, указатели на реализации). Дальше при проверке соответствия интерфейсу:

1) Сравнивает методы типа с методами интерфейса.
2) Если совпадение полное, тип считается реализующим интерфейс.

```golang
var w Writer  // Интерфейс (nil)
w = os.Stdout // Динамический тип — *os.File
```

Когда переменной интерфейсного типа присваивается конкретное значение, в [runtime](https://github.com/alexKudryavtsev-web/how-golang-works/blob/main/Runtime.md) создаётся структура `iface`.

Структура `iface` (сокращенное interface) выглядит так:

```golang
// файл src/runtime/runtime2.go

type iface struct {
	tab  *itab
	data unsafe.Pointer
}
```

Поле `tab` - указатель на таблицу методов. `itab` выглядит так:

```golang
// src/internal/abi/iface.go

type itab struct {
	Inter *InterfaceType
	Type  *Type
	Hash  uint32     // copy of Type.Hash. Used for type switches.
	Fun   [1]uintptr // variable sized. fun[0]==0 means Type does not implement Inter.
}
```

Где:

- `inter` — тип интерфейса (`Writer`).
- `_type` — динамический тип (`*os.File`).
- `fun` — массив указателей на методы.

Поле `data` — указатель на значение (в примере - `os.Stdout`)

### Динамическая диспетчеризация

Когда вызывается метод через интерфейсную переменную, Go должен определить конкретную реализацию метода во время выполнения. Этот процесс называется ***динамической диспетчеризацией***.

```golang
w.Write(data) // w имеет тип статический Writer и динамический тип *os.File
```

Здесь:

1) Доступ к `itab`: сначала runtime получает доступ к структуре `iface`, связанной с переменной `w`.
2) Поиск в таблице методов: в `itab` проверяется поле `fun` — массив указателей на методы. Для интерфейса `Writer` с единственным методом `Write`, `fun[0]` содержит адрес `(*os.File).Write`.
3) Косвенный вызов: будет использован указатель из `fun[0]` для вызова конкретной реализации метода.

## Nil-интерфейсы и пустые интерфейсы

Nil-интерфейс — это интерфейсная переменная, у которой и динамический тип, и значение равны nil. Такой интерфейс находится в «нулевом» состоянии:

```golang
var w io.Writer  // тип: io.Writer, значение: nil, динамический тип: nil
```

Есть тонкая разница между nil-интерфейс от интерфейсом, содержащем nil-указатель.

```golang
var buf *bytes.Buffer      // buf = nil
var w io.Writer = buf      // w содержит (динамический тип: *bytes.Buffer, значение: nil)
```

В первом случае вызов метода приведёт к панике (нет реализации), во втором — вызовется метод `*bytes.Buffer`, который должен корректно обрабатывать nil-получатель.

Пустой интерфейс `interface{}` не имеет методов, поэтому ему удовлетворяет любой тип. В runtime он представлен структурой `eface`:

```golang
// src/runtime/runtime2.go

type eface struct {
    _type *_type         // информация о динамическом типе
    data  unsafe.Pointer // указатель на значение
}
```

Пустые интерфейсы часто применяются для:

- Универсальных контейнеров (например, []interface{}).
- Функций, принимающих произвольные аргументы (fmt.Print).
- Рефлексии.

Использование пустых интерфейсов лучше минимизировать из-за этих проблем:

1) Частые преобразования типов (type assertions) создают дополнительную нагрузкую
2) Отсутствие статической проверки типов увеличивает риск runtime-ошибок
3) При присвоении не-pointer значения в `interface{}`, аллокатор памяти обычно вынужден аллоцировать это значение в куче, если его нельзя оставить на стеке. Но если в `interface{}` помещается указатель или тип, уже содержащий указатель  аллокации данных может и не быть.

## Type Assertion и Type Switch

Go предоставляет ряд механизмов для проверки соответствия динамического типа: Type Assertion и Type Switch.

***Type Assertion*** занимается проверкой и преобразованию типу:

```golang
val, ok := интерфейс.(конкретный_тип)  // Безопасная форма
val := интерфейс.(конкретный_тип)      // Паника при несоответствии
```

Работает по этому алгоритму:

1) Проверка `_type` в `iface`/`eface`

    - Для непустых интерфейсов (`iface`) сравнивается поле `_type` из `itab` с целевым типом.
    - Для пустых интерфейсов (`eface`) проверяется поле `_type` напрямую.

2) Возврат результата

    - Если типы совпадают, `data` копируется в выходную переменную (с учётом размера типа).
    - При несоответствии: в безопасной форме (`ok`) возвращается `nil` и `false`, в небезопасной — паника.

***Type Switch*** предоставляет множественную проверку типа:

```golang
switch v := x.(type) {
case int:
    fmt.Printf("int: %d\n", v)
case string:
    fmt.Printf("string: %s\n", v)
default:
    fmt.Printf("unknown: %T\n", v)
}
```

Работает по этому алгоритму:

1) Компиляция в if-цепочку:

    - Компилятор преобразует `type switch` в серию сравнений `_type` с каждым `case`.
    - Порядок сравнений соответствует порядку `case`-ов в коде.

2) Использование `_type`:

    - Для каждого case T генерируется проверка на соответствие `_type`.
    - Ветка `default` выполняется, если ни один case не сработал.
