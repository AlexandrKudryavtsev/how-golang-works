# Unsafe

Пакет `unsafe` позволяет работать с памятью на более низком уровне, чем обычно разрешено в Go. Это мощный, но очень опасный инструмент.

## Смещения в структурах, выравнивание типов

Перед изучением `unsafe` надо понять, что такое смещение и выравнивание в структурах. Рассмотрим пример:

```golang
type Example struct {
	a bool    // 1 байт
	b int32   // 4 байта
	c float64 // 8 байт
	d int16   // 2 байта
}
```

Кажется, что размер этой структуры 15 байт, но на самом деле - 24 байта. Все дело в выравнивании типа и смещениях:

- ***Выравнивание типа*** - это требование, чтобы адрес переменной определенного типа был кратен некоторому числу (обычно размеру типа). Например, `int32` имеет выравнивание 4 байта, значит его адрес должен быть кратен 4. Для обеспечения выравнивания к типу добавляется ***padding***.

- ***Смещение поля*** - это байтовое смещение от начала структуры до конкретного поля.

- ***Размер структуры*** всегда кратен максимальному выравниванию среди ее полей.

Разберем, как будет устроена в памяти структура `Example`:

1) `a` - смещение 0 байт, требует выравнивания в 1 байт.
2) `b` - смещение 1 байт, требует выравнивания в 4 байта. "Адрес" это поля не кратен 4-ем, поэтому будет добавлен padding размером 3 байта. Теперь `b` займет 3 байта padding и 4 байта собственного размера.
3) `c` - смещение 8 байт, требует выравнивания в 8 байт. "Адрес" поля `c` кратен 8, поэтому padding не нужен.
4) `d` - cмещение 16 байт, требует выравнивания в 2 байта. "Адрес" поля `d` кратен 2, поэтому padding не нужен. 

Итого структура `Example` займет `1 + 3 + 4 + 8 + 2 = 18` байт, но размер структуры должен быть кратен максимальному выравниванию - 8, поэтому добавляется еще 6 байт padding в конце.

> Для избежания этой проблемы надо размещать поля в порядке от больших по размеру к меньшим.

Оптимальным расположением полей будет такое:

```golang
type Example struct {
	c float64 // 8 байт
	b int32   // 4 байта
	d int16   // 2 байта
	a bool    // 1 байт
}
```

Теперь `Example` займет 16 байт. 1 байт будет добавлен, чтобы размер структуры был кратен максимальному выравниваю 8.

## Основы unsafe

Пакет `unsafe` содержит несколько ключевых элементов:

- `unsafe.Pointer`: универсальный указатель, который может ссылаться на любой тип данных. Это мост между произвольными типами Go и низкоуровневой памятью.
- `uintptr`: целочисленный тип, способный хранить адрес памяти. Используется для арифметики указателей.
- `Sizeof`, `Offsetof`, `Alignof`: функции для получения размера типа, смещения поля в структуре и выравнивания типа соответственно.

```golang
type Example struct {
	flag    bool
	counter int64
	pi      float32
}

func main() {
	// Размер типа
	fmt.Println("Size of int:", unsafe.Sizeof(int(0)))

	// Работа со структурой
	ex := Example{flag: true, counter: 42, pi: 3.14}

	// Получаем указатель на структуру как unsafe.Pointer
	ptr := unsafe.Pointer(&ex)

	// Доступ к полям через смещения
	flagPtr := (*bool)(unsafe.Pointer(uintptr(ptr) + unsafe.Offsetof(ex.flag)))
	counterPtr := (*int64)(unsafe.Pointer(uintptr(ptr) + unsafe.Offsetof(ex.counter)))
	piPtr := (*float32)(unsafe.Pointer(uintptr(ptr) + unsafe.Offsetof(ex.pi)))

	fmt.Println("Original:", ex)
	*flagPtr = false
	*counterPtr = 100
	*piPtr = 1.618
	fmt.Println("Modified:", ex)

	// Преобразование между типами
	var x int64 = 0x1122334455667788
	xPtr := unsafe.Pointer(&x)
	bytes := (*[8]byte)(xPtr)
	fmt.Printf("Bytes of int64: %v\n", bytes)

	// Опасное преобразование типов
	var y float64 = 3.1415
	yPtr := *(*uint64)(unsafe.Pointer(&y))
	fmt.Printf("Float64 as uint64: 0x%x\n", yPtr)
}
```

## Внутренняя реализация unsafe

Внутри Go `unsafe.Pointer` — это просто указатель на память без привязки к типу. Компилятор Go обрабатывает его особым образом, позволяя преобразовывать в любой другой указатель. Вот как это выглядит на уровне runtime:

```golang
// https://github.com/golang/go/blob/master/src/unsafe/unsafe.go#L15
type ArbitraryType int // ArbitraryType - фиктивный тип, используемый только для документации

// https://github.com/golang/go/blob/master/src/unsafe/unsafe.go#L184
type Pointer *ArbitraryType
```

Когда разработчик используе `unsafe.Pointer`, компилятор отключает проверки типов и генерирует прямой доступ к памяти. Это похоже на приведение типов в C через `void*`.

Для арифметики указателей используется `uintptr`, который представляет собой целое число, достаточно большое для хранения адреса памяти. Например:

```golang
ptr := unsafe.Pointer(&s)
nextAddr := uintptr(ptr) + unsafe.Sizeof(s.public)
nextPtr := unsafe.Pointer(nextAddr)
```

Важно помнить, что `uintptr` — это просто число, и сборщик мусора не отслеживает его как указатель. Это может привести к проблемам, если память будет перемещена.

## Проблемы unsafe

1. Обход системы типов.

`unsafe` позволяет обойти систему типов Go, что может привести к неожиданному поведению или паникам, если типы не совместимы.

2. Портится переносимость кода.

Код с `unsafe` может зависеть от размера типов, выравнивания и порядка полей в структуре. Эти параметры могут отличаться на различных платформах. Внедрение `unsafe` может привести к проблемам с переносимостью. 

3. Проблемы с GC.

Сборщик мусора не отслеживает `uintptr`. Если адрес будет сохранен в uintptr, а исходный объект будет перемещен, это приведет к неопределенному поведению.

## Рекомендации

Использовать `unsafe` следует только в функционалах, где требуется экономия наносекунд, и с максимальным документированием, особенно платформозависимых параметров. Также его приходится применять, когда происходит взаимодействие с C-кодом.

Внутри Go `unsafe` используется активно для syscall-ов, быстрого преобразования типов без промежуточных аллокаций, быстрого чтения/записи без копирования данных.

## Источники

- [pkg.go.dev/unsafe](https://pkg.go.dev/unsafe)
- [Исходный код Go 1.24](https://github.com/golang/go/releases/tag/go1.24.2)
