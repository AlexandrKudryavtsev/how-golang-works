# Сборщик мусора

Go-разработчики занимаются памятью опосредованно: аллокацией памяти и удалением памяти из стека занимается часть runtime - аллокатор. Он был детально рассмотрен в предыдущей статье. Однако возникает вопрос: кто занимается удалением из кучи? Для этого есть ***сборщик мусора (Garbage Collector, GC)***.

## Go Garbage Collector

Сборщик мусора (или GC, от garbage collector) — это система, которая освобождает память от имени приложения, определяя, какие её участки больше не используются. GC предоставляется runtime.

Некоторые значения в Go не требуют работы GC. Например, локальные переменные без указателей обычно размещаются на стеке горутины — компилятор заранее определяет время их жизни, что эффективнее динамического выделения. Такой способ называется «стековым размещением».

Если компилятор не может предсказать время жизни значения (например, из-за динамического размера или транзитивных ссылок), оно «убегает» в кучу (heap). Такие выделения требуют GC, так как их очистку невозможно спланировать на этапе компиляции. Escape analysis зависит от контекста и может меняться между версиями Go.

## Алгоритм Go GC

Go GC относится к трассирующим сборщикам, он развивает идею mark-sweep collection.

***Mark-sweep collection***: делится на два этапа. Этап mark, помечающий объекты живыми, и этап sweep, который удаляет все неживые объекты.

1) Корень помечается живым. Корнем, может быть, например, глобальная переменная.
2) Помечаются живыми все объекты, на которые введут ссылки из корня. 
3) Эта процедура повторяется для помеченных живыми объектами. 
4) По аналогии помечаются все остальные корневые элементы.

Алгоритм mark-sweep хорошо параллелится, за счет чего может работать быстро. Но в результаты получается сильно фрагментированная память. 

Основные понятия Go GC:

- ***Объект*** - динамически выделенный участок памяти, содержащий одно или несколько значений Go

- ***Указатель*** - адрес памяти, ссылающийся на значение внутри объекта. Сюда входят не только типы *T, но и части встроенных типов: строки, срезы, каналы, карты и интерфейсы содержат адреса, которые должен отслеживать GC

Объекты и указатели между ними образуют граф объектов. Для поиска "живой" памяти GC обходит этот граф, начиная с корней программы (локальных и глобальных переменных). Этот процесс называется сканированием. Объект считается достижимым (reachable), если GC может его обнаружить.

Работа GC делится на две основные фазы:

- ***Фаза пометки (mark phase)*** - идентификация используемых ("живых") объектов

- ***Фаза очистки (sweep phase)*** - освобождение неиспользуемой памяти

Ключевой момент: память нельзя освободить до завершения полного сканирования, так как непросканированные указатели могут сохранять объекты "живыми". Это требует строгого разделения фаз пометки и очистки.

GC может находиться в ***неактивном состоянии (off)***, когда нет работы для него. Он попадает в неактивное состояние сразу же после фазы очистки. Этот повторяющийся процесс называется ***циклом GC***:

1) Очистка (sweeping)
2) Бездействие (off)
3) Пометка (marking)

Именно в таком порядке, где очистка идет первой.

## GOGC и GOMEMLIMIT

Затраты GC можно свести к двум основным ресурсам:

- Физическая память:

    - ***"Живую" (live) память*** — память, которую 
    предыдущий цикл GC определил как используемую.
    - ***Новую выделенную память*** — память, выделенную до фазы пометки (может быть как живой, так и мусором).
    - Метаданные GC (их объём незначителен по сравнению с основной памятью).

    Определяется формулой:
    
    `Затраты памяти GC для цикла N = live-память (цикл N-1) + новая выделенная память`

- Процессорное время (CPU):

    Определяется формулой:

    `CPU для цикла N = Фиксированные затраты + (Средняя стоимость на байт × live-память)`

    где:
    
    - фиксированные затраты — подготовка данных (незначительна)
    - основные затраты — пометка и сканирование, которые зависят от реализации GC и самой программы. Например, если программа использует связанные списки, сканирование будет затратнее.

Эта модель показывает, что общие затраты CPU зависят от частоты запуска GC:

> Чем реже GC, тем меньше нагрузка на CPU, но тем больше потребление памяти. 

Частота запуска GC — ключевой параметр для этого компромисса, и в Go её можно настраивать через `GOGC`. `GOGC` задает целевой размер кучи после каждого цикла GC — то есть, какой максимальный объём памяти может быть выделен до следующего запуска сборщика. 

Формула расчета: `Целевой размер кучи = Live-память + (Live-память + GC roots) × GOGC / 100`

Где `GC roots` корни GC - стек горутин + глобальные переменные. По умолчанию, `GOGC` равен 100.

1) При увеличении GOGC: память растёт, но GC реже (меньше нагрузка на CPU).
2) При уменьшении GOGC: память экономится, но GC работает чаще (больше CPU).

Также можно выключить GC через `GOGC=off` - тогда память не будет ограничиватся.

Однако, иногда память может в моменте сильно увеличиться и потом откатиться назад, например, при обработке файла или сетевого запроса. Тогда `GOGC` будет ориентироваться на пиковое значение памяти и целевой размер памяти будет считаться некорректно.

Для решения этой проблемы появился мягкий лимит памяти (Memory Limit), задаваемый через `GOMEMLIMIT`. Он ограничивает общее потребление памяти рантаймом Go (куча + другие структуры), предотвращая исчерпание памяти при всплесках нагрузки. В отличие от `GOGC`, который лишь регулирует баланс CPU/память, `GOMEMLIMIT` гарантирует, что программа не превысит заданный порог.

При приближении к лимиту GC активируется чаще, чтобы снизить использование памяти. Однако лимит не жёсткий — если его слишком сильно занизить, GC начнёт тратить до 50% CPU (thrashing), что замедлит программу. Поэтому лимит стоит устанавливать с запасом (~10-20% от реально доступной памяти).

> Memory limit отлично подходит для управляемых сред (Kubernetes, сервисы), но требует осторожности в остальных случаях!

## Издержки

GC в Go работает преимущественно параллельно с программой, делая короткие stop-the-world крайне редко. Это снижает задержки (например, время обработки веб-запросов), но может немного уменьшить общую пропускную способность. Хотя параллельный GC требует дополнительных ресурсов, он избегает длительных пауз, зависящих от размера кучи, и со временем его производительность улучшается как по задержкам, так и по скорости работы.

Ключевой фактор, влияющий на производительность GC, — его частота: чем реже он запускается, тем меньше нагрузка на CPU и тем лучше latency (издержки). Это достигается настройкой параметров (в основном увеличиванием `GOGC`) и оптимизацией кода.

## Дополнительные возможности

Сборщик мусора (GC) в Go автоматически освобождает память, когда объекты становятся недостижимыми, что упрощает разработку. Однако в стандартной библиотеке есть функции, позволяющие отслеживать и влиять на этот процесс:

- ***Финализаторы (runtime.SetFinalizer)*** — вызываются перед удалением объекта, но могут ненадолго «воскресить» его.
- ***Слабые указатели (weak.Pointer)*** — позволяют ссылаться на объекты, не препятствуя их сборке.
- ***Очистка (runtime.AddCleanup)*** — регистрирует функции для выполнения при завершении работы (например, освобождение ресурсов).

## Источники

- [A Guide to the Go Garbage Collector
](https://tip.golang.org/doc/gc-guide)
- [Комментарии файла runtime/mgc.go](https://github.com/golang/go/blob/master/src/runtime/mgc.go)