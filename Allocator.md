# Аллокатор памяти

***Аллокатор памяти Go*** - это часть runtime Go, управляющая выделением и освобождением памяти во время выполнения программы. Аллокатор тесно связан со ***сборщиком мусора***, но притом сборкой мусора он не занимается.

### Аллокаторы

Каждый аллокатор можно оценивать по этим критериям:

1) Скорость работы

    - Кеш-локальность: аллоцированная память должна находиться близко друг к другу.
    - Выделение недавно освобожденных блоков (которые остались в кешах): чтобы потоки программы работали с ранее использованными блоками.

2) Масштабируемость

    - Поддержка работы на нескольких ядрах CPU.
    - Работа с участками памяти разного размера: чтобы аллокатор мог успешно выделять как маленькие, так и большие участки памяти.

3) Эффективность использования памяти

    - Оптимальные структуры хранения данных: чтобы на разметку данных было потрачено как можно меньше памяти.
    - Минимальная фрагментация.

4) Безопасность

    - Защита от ошибок использования.
    - Защита от атак (например, переполнений буфера).

Эти критерии противоречат друг другу, поэтому необходимо находить компромиссные решения. Например, если делать аллокатор более безопасным, то это непременно отразится на скорости. 

Аллокаторы обычно предоставляют такой интерфейс:

1) `create` – создает аллокатор и выделяет для него заданный объем памяти.
2) `allocate` – запрашивает блок памяти указанного размера из области, управляемой аллокатором.
3) `deallocate` – освобождает конкретный выделенный блок, возвращая его аллокатору для повторного использования.
4) `free` – освобождает все выделенные блоки, но сохраняет за аллокатором первоначально выделенную память (не возвращает её системе).

### Линейный аллокатор (Linear allocator)

1) Аллокатор получает начальный блок памяти и сохраняет указатель на его начало.
2) Для отслеживания свободной памяти используется дополнительный указатель или смещение.
3) При каждом запросе памяти (`allocate`) аллокатор:

    - Резервирует требуемый блок от текущей позиции.
    - Сдвигает указатель/смещение на размер выделенного блока.

4) Освобождение отдельных блоков (`deallocate`) не поддерживается - память можно освободить только целиком (`free`).

Линейный аллокатор выглядит примитивно, но зато он очень удобен, когда надо быстро записать информацию и потом ее удалить всю за раз.

### Блочный аллокатор (Pool allocator)

1) Аллокатор получает большой непрерывный участок памяти и делит его на блоки фиксированного размера.
2) Все блоки имеют одинаковый размер, заданный при создании аллокатора.
3) Поддерживается список свободных блоков (free list), позволяющий быстро находить доступные участки.

Блочный аллокатор поддерживает все 4 операции. Однако в блочном аллокаторе не выполняется кеш-локальность из-за чего блочный аллокатор хуже оптимизируем кешем.

### Стековый аллокатор (Stack allocator)

Стековый аллокатор развивает линейный аллокатор. В нем перед каждым выделяемым блоком памяти, добавляется блок ***заголок (header)***, содержащий информацию о том, сколько их было выделено. Благодаря этому стековый аллокатор поддерживает `deallocate`.

### Malloc

***Malloc*** - самый известный аллокатор памяти, который используется в C/C++ и языках, интерпетаторы которых написаны на них. Malloc использует все три выше описанных подхода.

В нем есть список свободных блоков. Каждый элемент из этого списка - это указатель на хедер, содержащий информацию о том, сколько после него блоков свободно для записи. Также есть смещение относительно начала. При записывании N блоков, этот указатель смещается на N + размер хедера, содержащего информацию о занятых блоках. Когда же выделенная память закончилась, то можно в список свободных блоков добавить указатель на новую выделенную память.

У Malloc есть ряд проблемы:

1) Не соблюдается кеш-локальность
2) Синхронизация потоков приводит к тому, что доступ к памяти становится медленнее, например, из-за мьютекса.
3) Фрагментация кучи. Дефрагментизировать можно только рядом стоящие свободные блоки. Из-за этого будут непременон появляться проблемы с фрагментацией.

Развитием Malloc является ***TCMalloc (thread cache Malloc)***. Он вводит:

1) Кеши для потоков. В нем треды могут работать с небольшим выделенным только для него кешем и только по мере необходимости этот кеш будет записываться в основную память. Теперь треды будут быстро работать с кешем, а не медленно со всей памятью.
2) Иерархическая модель хранения данных. Теперь хранимые данные деляться на классы. В 1-ом классе - объекты от 1 до 8 байт, 2-ом -  от 1 до 16 байт и т.д.

### Аллокатор Go

Аллокатор Go развивает идею TCMalloc и адаптирует его под специфику Gо-программ.

1) Аллокатор Go в случае необходимости, запрашивает у ОС большой кусок памяти - ***арену*** (зависит от ОС, в Linux обычно 64 МБ). Арена же разбивается на ***страницы page*** (по 8 КБ).
2) Далее страницы склеиваются в ***спаны span*** размерами 8 КБ (одна страница), 16 КБ (две страницы), 32 КБ (три страницы) и т.д.
3) При сохранении объекта, он сохраняется в каком-то span:

    - Если объект размером 16 KB, он сохранится в спане размером 16 КБ. Этот объект будет занимать все место. 
    - Если же он был размером 12 KB, он тбы оже сохранился в спане размером 16 КБ, но в спане осталось бы `(16-12) / 16 * 100 = 25%` незаполненного места.
    - В худшем случае, span размером 16 КБ будет незаполнен на `(16-9) / 16 * 100 = 43,75%`.
    - С увеличением размера спана, этот процент будет уменьшаться.

Такой подход аллокатора Go делает фрагментацию памяти предсказуемой. И на самом деле, процент неиспользуемой памяти будет не таким большим и в большинстве случае потери допустимые.

### Escape анализ

***Escape анализ*** - это процесс, выполняемый во время компиляции программы, который анализирует:

- Где в программе создаются объекты
- Как эти объекты используются

Основная функция: определять, можно ли разместить объект в стеке (для более быстрого доступа) или необходимо выделять память в куче. Для этого используется универсальное правило:

> Однако, если компилятор не может доказать, что на переменную не ссылаются после возврата функции, то компилятор должен выделить переменную в куче, собираемой мусором, чтобы избежать ошибок висячего указателя. Кроме того, если локальная переменная очень большая, может быть разумнее хранить ее в куче, а не в стеке. 

Частныи случаи:

1) если функция возвращает указатель на переменную, то эта переменная будет помещена не в фрейме стека функции, а в кучу.

2) если один элемент массива/слайда или полей структуры попадает в кучу, то весь массив/слайд или структура попадут тоже в кучу.

Заблуждением будет думать, что использование `new` и `make` создаст переменную сразу в куче. Аналогично с использованием `interface{}`. Где сохранится переменная: в стеке или куче, определяется только правилом escape анализа.

### Детали аллокации на стеке

В Go аллокация объектов в стеке происходит быстрее, чем в куче, благодаря простоте управления памятью. В стеке выделение и освобождение памяти сводится к перемещению указателя, а данные обладают высокой кеш-локальностью, что ускоряет доступ. В отличие от этого, куча требует сложных алгоритмов выделения памяти, борьбы с фрагментацией, что замедляет работу.

Однако стек в Go не имеет фиксированного размера и может динамически расти, что создает накладные расходы. Ранние версии Go использовали ***сегментированный стек***, где при нехватке памяти выделялись новые сегменты, связанные указателями. Это вызывало проблему "горячего разделения" (hot split) — частые выделения и освобождения сегментов при глубокой рекурсии или циклах снижали производительность.

Современные версии Go перешли на ***непрерывный стек***: при нехватке места весь стек перемещается в новый участок памяти с копированием данных. Это устраняет проблему "горячего разделения", но требует времени на копирование. Такой подход улучшает производительность для рекурсивных вызовов и сложных сценариев, хотя и не избавляет полностью от накладных расходов при расширении.

Другое преимущество стековой аллокации - минимальное воздействие на сборщик мусора. В отличие от кучи, где GC должен отслеживать и освобождать каждый объект индивидуально, память стека освобождается мгновенно и целиком при завершении, например, горутины. Весь стек горутины рассматривается как единый блок памяти, который просто перестает существовать, когда горутина завершает работу. Это не только снижает нагрузку на GC, но и полностью исключает проблему фрагментации памяти, характерную для кучи.

### Методы уменьшения аллокаций

***Object Pool (Пул объектов)*** - паттерн управления памятью, при котором заранее создаётся набор инициализированных объектов для многократного использования. Принцип работы:

- При запросе объекта система берёт его из пула вместо создания нового
- После использования объект возвращается в пул вместо удаления
- Реализуется через sync.Pool или аналогичные структуры данных

Преимущества:

- Снижает нагрузку на сборщик мусора (GC)
- Уменьшает количество аллокаций
- Повышает производительность для часто используемых объектов

***Region-Based Memory Management (Региональное управление памятью)*** - подход к управлению памятью, при котором выделяются отдельные регионы (области) для групп связанных объектов.

- Память выделяется и освобождается целыми регионами
- Упрощает управление жизненным циклом объектов
- Может сочетаться с другими методами управления памятью

***Арены (экспериментальное API)*** - экспериментальный механизм в Go для батчевого управления памятью, позволяющий выделять и освобождать множество объектов одновременно.

- Работает с блоками памяти (чанками) по 8MB
- Позволяет освобождать все объекты в арене одной операцией
- Ограниченная поддержка для строк и словарей (требует unsafe)
- Особенно полезен для сценариев с массовым созданием временных объектов
