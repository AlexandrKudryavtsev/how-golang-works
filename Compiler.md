# Компилятор

___Компилятор___ преобразует исходный код в исполняемый компьютером двоичный код. На данный момент он написан на Go с вставками на Assembler.

Компилятор обычно называется gc (Go Compiler). Не стоит путать gc с другой аббревиатурой GC (Garbage Collector).

Компиляция происходит условно в 2 этапа:

1) Front-end: Анализ кода и построение AST.
2) Back-end: Преобразование оптимизированного AST в машинный код.

Еще выделяют Middle-end - основную часть оптимизации Front-end части.

Рассмотрим все этапы подробнее:

### 1. Анализ

На первом этапе компиляции происходит разбиение исходного кода на токены. Токеном может быть, например, ключевое слово, оператор, идентификатор и т.д. Токен содержит информацию о своем типе и своем значении. Этот этап называется ___лексический анализ___.

Дальше идет разбор полученной последовательности токенов - ___синтаксический анализ___.  После него для каждого файла строится свое ___абстрактное синтаксическое дерево AST (abstract syntax tree)___. Каждый узел AST соответствует какому-то выражению исходного кода. Также AST хранит информацию о позиции узла в исходном коде. Это позволяет выводить понятные человеку сообщения об ошибках.

### 2. Проверка типов

На втором этапе происходит ___проверка типов (type checking)___. Прежде всего, сначала происходит разрешение имен - сопоставление сущностей и их определений - и вывод типов. Затем уже происходит проверка типов на корректность использования в операторах, вызов методов и т.д.

### 3. Построение IR (noding)

На третьем этапе происходит преобразование AST дерева во ___внутреннее представление компилятора IR___ (internal representation).

Процесс преобразования узлов AST в узлы IR называется ___noding___. Для этого используется процесс ___Unified IR___ - он строит IR с учетом уже проведенного type checking.


### 4. Middle-end

Над IR-представлением выполняются несколько оптимизаций:

1) Удаление мертвого кода.
2) Ранняя девиртуализация: вызов метода напрямую, без обращения к виртуальной таблице методов. Смотри статью про "Реализация интерфейсов".

3) Встраивание вызовов маленьких функций.

4) Escape анализ: определение переменных, которые будут перемещены в кучу после выполнения функции. 

Примечание: часть мертвого кода может удалиться на этапе построения IR.

### 5. Walk

Финальный проход по IR-представлению называется "walk" и служит двум целям:

1) Разбивает сложные инструкции на более простые, вводя временные переменные и учитывая порядок вычислений. Этот этап также называют "order".

2) Преобразует высокоуровневые конструкции Go в более примитивные. Например, инструкции `switch` превращаются в бинарный поиск или таблицы переходов, а операции с картами и каналами заменяются вызовами рантайма.

### 6. Генерация SSA

На четвертом этапе происходит генерация SSA (Static Single Assignment). ___SSA___ — низкоуровневое промежуточное представление с особыми свойствами, которые упрощают оптимизацию и последующую генерацию машинного кода.

Во время преобразования IR в SSA:

- будут внедрены ___встроенные функции (intrinsics)___ — специальные функции, которые компилятор заменяет на высокооптимизированный код в зависимости от ситуации. Например, заместо math.Sqrt подставится вызов инструкции CPU `VSQRT.F64` (для ARM) и `SQRTSD` (для x86).

- будет ___упрощение узлов___. Например, range цикл преобразуется в обычный for.

Дальше будут применены машинно-независимые оптимизации и правила. Например: удаление мёртвого кода, устранение избыточных проверок на nil и удаление неиспользуемых ветвлений.

### 7. Генерация машинного кода

На финальном четвертом этапе происходит генерация машинного кода.

Сначала будут "lower" проходы SSA. Этот обход преобразует общие SSA-значения в их машинно-зависимые аналоги.

После того как SSA приведено к виду, специфичному для целевой архитектуры, выполняются финальные оптимизации. 

Компилятор Go превращает оптимизированное SSA в машинные инструкции, которые ассемблер преобразует в объектный файл — он содержит не только исполняемый код, но и метаданные для `reflection`, отладки и линковки.

### 8. Линковка

На создании объектного файла заканчивается работа компилятора. Итоговый исполняемый файл появляется только после линковки, которая объединяет этот объектный файл с другими зависимостями (например, стандартной библиотекой Go).


### Источники

- [README из cmd/compile Go](https://github.com/golang/go/blob/release-branch.go1.23/src/cmd/compile/README.md)



