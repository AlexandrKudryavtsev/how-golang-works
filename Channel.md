# Каналы

***Каналы (channels)*** в Go — механизм для безопасной передачи данных между горутинами и их синхронизации. Они обеспечивают обмен информацией без явных блокировок.

***Небуферизованный канал*** `make(chan T)` — синхронный канал, где отправка `ch <- data` блокирует отправителя до появления получателя `<-ch`, а получение — получателя до появления отправителя. Работает по принципу "рандеву".

***Буферизованный канал*** `make(chan T, N)` — асинхронный канал с очередью размера `N`. Отправка блокируется только при заполненном буфере, получение — только при пустом. Позволяет временно накапливать данные.

Каналы обладают рядом полезных свойств:

1) Каналы потокобезопасны (goroutine-safe). Операции `ch<-` и `<-ch` безопасны для конкурентного использования из разных горутин без дополнительных блокировок.
2) Буферизированные каналы хранят данные и реализуют доступ к ним через FIFO. 
3) Каналы передают данные между горутинами.
4) Каналы могут заблокировать горутину: операции чтения/записи приостанавливают горутину, пока не смогут выполниться.

## Структура hchan

При создании каналы через `make` в куче появляется объект типа `hchan`. Сам канал является указателем на эту структуру. 

```golang
// https://github.com/golang/go/blob/master/src/runtime/chan.go#L34-L55

type hchan struct {
	qcount   uint           // текущее количество элементов в буфере
	dataqsiz uint           // размер циклического буфера
	buf      unsafe.Pointer // указатель на массив элементов буфера
	elemsize uint16         // размер одного элемента
	closed   uint32         // флаг закрытия канала (0 - открыт, 1 - закрыт)
	elemtype *_type         // тип элементов канала
	sendx    uint           // индекс записи в буфер
	recvx    uint           // индекс чтения из буфера
	recvq    waitq          // очередь ожидающих получателей
	sendq    waitq          // очередь ожидающих отправителей

	// lock защищает все поля hchan, а также некоторые поля
	// заблокированных на этом канале горутин (sudogs).
	//
	// Не изменяйте статус другой горутины при удержании этой блокировки
	// (в частности, не переводите горутину в состояние ready),
	// так как это может привести к взаимоблокировке (deadlock)
	// при сжатии стека.
	lock mutex
}
```

Где:

- `qcount` - количество элементов, которые хранятся момент `buf`.
- `dataqsiz` - размерность буфера.
- `buf` - указатель на буфер.
- `recvx`, `sendx` - индексы, из которых будет происходить чтение / запись в буфер.

> Буфер в `hchan` циклический. Это означает, что при его заполнении, запись начнет в начало буфера (когда это начало станет снова свободным).

- `closed` - флаг закрыт ли буфер. Он реализован через `uint32` для атомарности.
- `elemsize`, `elemtype` - информация о типе хранящихся данных.
- `recvq`, `sendq` - указатели на связанные списки горутин, ожидающих чтения / записи.
- `lock` - мьютекс, используемый для синхронизации.

## Запись / чтение в канал

Рассмотри `hchan` подробнее:

1) Изначально `recvx` и `sendx` равны 0.
2) При записи в буфер, элемент попадет в ячейку с индексом `sendx` и значение `sendx` увеличится на единицу. И так до тех пор, пока буфер не заполнится.
3) При чтении в буфер, причитанным элементом будет элемент с индексом `recvx`, `recvx` сместится на единицу. Когда будет прочитан конец буфера (то есть ячейка, индекс которой равен `dataqsiz`), `recvx` обнулится.
4) При попытке записать в буфер, `sendx` которого равна `dataqsiz`, будет проверено: не освободилось ли начало буфера. Если да, то `sendx` обнулится и запись начнется в начало буфера.

Благодаря этому реализуется принцип FIFO для записи / чтения.

---

Теперь очевидно, что:

- при записи в канал `ch <- data`, горутина блокирует мьютекса и без проблем с конкурентным доступом добавляет в буфер копию (именно копию) `data`, потом она  разблокирует мьютекс разблокирует.
- при чтения из канала `<- ch`, все будет аналогично.

---

Однако что будет при записи горутины в заполненным буфер `ch <- data`? Рассмотрим этот кейс:

1) Вызовется [`gopark`](https://github.com/golang/go/blob/master/src/runtime/proc.go#L443-L461). Она будет напрямую работать с планировщик, переведеть ее в состояние `waiting` и отвяжет от треда.
2) Горутина добавится в `sendq`:

`sendq` - это связный список, и реализован структурой `waitq`:

```golang
// https://github.com/golang/go/blob/master/src/runtime/chan.go#L57-L59

type waitq struct {
	first *sudog
	last  *sudog
}
```

`sudog` - это структура, которая хранит саму горутина `g` и элемент `elem`, который она хотела записать.

3) Горутина будет храниться в `sendq` до тех пор, пока не освободится ячейка буфера (то есть пока она не будет прочитана). Когда же читающая горутина прочитает ее, то она же и положит эту горутину в буфер и вызовет функцию [`goready`](https://github.com/golang/go/blob/master/src/runtime/proc.go#L479-L483) для ее пробуждения! Благодаря этой оптимизации, мьютекс вызовется только один раз.

> Если говорить точнее, то горутина будет храниться в `sendq`, пока все предыдущие в очереди горутины не будут обработаны.
 
> После вызова `goready` статус горутины измениться на `runnable`. Дальше планировщик ее найдет и добавит в очередь.

---

В обратной ситуации: при чтении из пустого канала, подход будет аналогичный. 

1) Горутина будет заблокирована при помощи `gopark`
2) Горутина попадет в `recvq`. Только теперь в `sudog` в `elem` будет указатель на переменную, в которую надо будет осуществить запись. 
3) Теперь же записывающая горутина, после пробуждения горутины, при помощи [`sendDirect`](https://github.com/golang/go/blob/master/src/runtime/chan.go#L392-L403).

--- 

> В небуферизованном канале запись и чтения будут сразу же напрямую из читаемой/записаемой горутины.


## Конструкция select

До этого каждый раз при чтении / записи в горутину при помощи `<-` на самом деле вызывались функции  [`chanrecv`](https://github.com/golang/go/blob/master/src/runtime/chan.go#L518-L686) и [`chansend`](https://github.com/golang/go/blob/master/src/runtime/chan.go#L176-L310):

```golang
func chansend(c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool {
    // ...
}

func chanrecv(c *hchan, ep unsafe.Pointer, block bool) (selected, received bool) {
    // ...
}
```

Внутри себя они реализует вышеизложенные действия. Но как видно, дополнительно они принимают параметр `block`. Он определяется, будет ли операция чтения / записи блокирующей. Если `block` равен false, то в случае, когда чтение / запись из канала невозможно, то функция завершит свое выполнение.

На самом деле, этот параметр нужен для реализации конструкции `select`:

1) `select` проверяет в случайном порядке все указанные канальные операции `case` и выполняет только один из готовых вариантов. Если готовы несколько — выбирается случайный. Каждый раз при чтении / записи, параметр `block` соответствующих функций будет равен `false`. Благодаря этому и возможен обход всех кейсов.
2) Если ни один `case` не готов, `select` блокирует горутину, пока хотя бы один из каналов не станет доступным (если нет `default`)
3) Секция `default` выполняется, если ни один другой `case` не готов. Это позволяет делать опрос каналов без блокировки.

Каждый вызов `select` реализуется через функцию [`selectgo`](https://github.com/golang/go/blob/master/src/runtime/select.go#L122-L543).

## Закрытие канала

При закрытии канала:

1) Проверка инициализирован ли канал. Если нет, то паника.
2) Блокируется мьютекс. 
3) Проверка закрыт ли канал. Если да, то паника.
4) Значение флага `closed` меняеться на `1`.
5) Все горутины в `recvq` прочитают zero-value.
6) Все горутины в `sendq` будут опущены. И это вызовет панику, поэтому записи всегда надо производить проверку: открыт ли канал.
7) Эти все горутины будут освобождены. 

Функция `close` является built-in, на самом деле логика закрытия находится в [`closechan`](https://github.com/golang/go/blob/master/src/runtime/chan.go#L414-L486).
